var app = angular.module("QueGui");

// controller for things list
app.controller("ThingsController", function($scope, $http, $rootScope, thingService, blockService, $interval, $document, tokenService) {
  var root = this;

  this.things = [];

  this.selectedThing = null;
  this.editMode = false;

  // thing authentication key
  this.authKey = null;

  // new thing to be added
  this.newThing = null;
  this.newControl = {};

  // custom thing
  this.customThing = {};
  this.customActions = [{
    name: "123",
    trigger: {},
    detrigger: {}
  }];

  // spark token is validated
  this.sparktokenvalidated = false;

  // check if spark token is real
  this.validateSparkToken = function() { this.sparktokenvalidated = this.newThing.id.length === 24; }

  // go to next page of add dialog
  this.addNextPage = function() {
    this.newThing.dialogPage++;

    // change page count
    switch (root.newThing.type) {
      case "spark":
        root.newThing.pageCt = 2;
        break;
      default:
        root.newThing.pageCt = 1;
        break;
    }
  }

  // previous page
  this.addPrevPage = function() {
    this.newThing.dialogPage--;
  }

  this.addFinish = function() {
    // initialize thing
    thing = {
      actions: [],
      data: {},
      name: root.newThing.name,
      desc: root.newThing.desc,
      tags: (root.newThing.tags || "").split(' ')
    };

    // initialize a potential block
    block = null;

    // is this a custom thing?
    switch(root.newThing.type) {
      case "manual":
        thing = _.extend(thing, JSON.parse(root.customThing));
        break;

      case "actions":
        thing.actions = root.customActions;
        break;

      // preprocessing for spark
      case "spark":
        root.newThing.actions = [];

        // prepend some code (the header)
        block = {
          name: thing.name + " Controller",
          desc: thing.desc,
          code: [
            "// Generated by Que on " + (new Date()).toString(),
            "que.getThingById(%THINGID%, function(thing, n) {"
          ]
        }

        // add each pin to the list
        _.each(root.newThing.pins, function(pinv, pin) {

          // for each output pin
          if (!root.newThing.pinMode[pin]) {

            // add controls for each pin automatically,
            // to make the user's job easier
            thing.data[pinv] = {
              value: false,
              name: pinv
            };

            // what type is the pin?
            pintype = pin[0] === "D" && "digital" || "analog";

            // add actions for each pin
            thing.actions.push({
              name: pinv,
              trigger: {
                method: "POST",
                url: "https://api.spark.io/v1/devices/"+root.newThing.id+"/"+pintype+"write",
                form: {
                  args: pin+","+(pintype === "digital" && "HIGH" || "255"),
                  access_token: tokenService.tokens.sparktoken
                }
              },
              detrigger: {
                method: "POST",
                url: "https://api.spark.io/v1/devices/"+root.newThing.id+"/"+pintype+"write",
                form: {
                  args: pin+","+(pintype === "digital" && "LOW" || "0"),
                  access_token: tokenService.tokens.sparktoken
                }
              }
            });


            // add the required code to the block
            block.code.push("  if (thing.data."+pinv+".value == true) {");
            block.code.push("    que.getActions(thing)."+pinv+".trigger(function(status) {");
            block.code.push("      // do something here when the pin turns on");
            block.code.push("    });");
            block.code.push("  } else {");
            block.code.push("    que.getActions(thing)."+pinv+".detrigger(function(status) {");
            block.code.push("      // do something here when the pin turns off");
            block.code.push("    });");
            block.code.push("  }");

          } else {
            // input pin

            // add actions for each pin
            thing.actions.push({
              name: pinv,
              trigger: {
                method: "POST",
                url: "https://api.spark.io/v1/devices/"+root.newThing.id+"/digitalread",
                form: {
                  args: pin,
                  access_token: tokenService.tokens.sparktoken
                }
              },
              detrigger: {}
            });


            // add the required code to the block
            block.code.push("  que.getActions(thing)."+pinv+".trigger(function(status, resp, body) {");
            block.code.push("    if (body.return_value) {");
            block.code.push("      // do something here when the pin is on");
            block.code.push("      que.log('"+pinv+" is on.');");
            block.code.push("    } else {");
            block.code.push("      // do something here when the pin is off");
            block.code.push("      que.log('"+pinv+" is off.');");
            block.code.push("    };")
            block.code.push("  });");

          }

        });

        // the last curly brace
        block.code.push("});");

        break;
    }

    // add the thing to the database serverside
    $http({
      method: "POST",
      url: "/things/add",
      data: angular.toJson(thing)
    }).success(function(data) {

      // clear thing cache
      thingService.cache = {};

      if (block) {
        // replace id
        block.code[1] = block.code[1].replace("%THINGID%", data.id);

        // and, if the block was defined, add it too
        $http({
          method: "POST",
          url: "/blocks/add",
          data: JSON.stringify(block)
        }).success(function() {
          $rootScope.$broadcast('updateBlocks', null);
          root.refresh();
        });
      } else {
        root.refresh();
      }
    });

  };

  // initialize the newThing object on cancel (or on start)
  // and the customThing JSON string if the user is adding a custom thing
  this.addCancel = function() {
    root.newThing = {
      dialogPage: 0,
      pageCt: 1,
      idClaimed: false,
      type: "",
      pins: {},
      pinMode: {},
      actions: {},
      finished: false
    }
    root.customThing = JSON.stringify({
      actions: [],
      data: []
    }, null, 2);
    root.customActions = [];
  }

  // run this now
  this.addCancel();

  // also, bind it to modal close
  $('#addThingModal').on('hidden.bs.modal', function(){
    root.addCancel();
    $scope.$apply();
  });

  // get all data from server
  thingService.getAllThings(function(data) {
    root.things = data;
  });

  // given a data type, get the textbox type it would go into
  this.getTypeFor = function(value) {
    if (value.type) {
      return value.type;
    } else {
      switch (typeof value.value) {
        case "number":
          return "number";
          break;
        case "boolean":
          return "checkbox";
          break;
        case "canvas":
        case "video":
          return "canvas";
          break;
        default:
          return "text";
          break;
      }
    }
  }

  // is this control represented as a button?
  this.isButton = function(v) {
    return v.type == "button";
  }

  // update backend on keypress
  this.updateThingData = function(id, key, value, callback) {
    data = {}
    data[key] = value;

    thingService.updateThingData(id, data, callback || function() {});
  }

  // convert from CamelCase or underscore-format to normal, smaced words
  this.convertIntoSpaces = function(string) {
    string = string
      // insert a space between lower & upper
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      // space before last upper in a sequence followed by lower
      .replace(/\b([A-Z]+)([A-Z])([a-z])/, '$1 $2$3')
      // uppercase the first character
      .replace(/^./, function(str){ return str.toUpperCase(); })// insert a space between lower & upper
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      // space before last upper in a sequence followed by lower
      .replace(/\b([A-Z]+)([A-Z])([a-z])/, '$1 $2$3')
      // uppercase the first character
      .replace(/^./, function(str){ return str.toUpperCase(); })
    return string.replace('-', ' ').replace('_', ' ');
  }

  this.removeThing = function(id, index) {
    root.things.splice(index, 1);
    thingService.removeThing(id, function() {});
  }

  // add a new control to the list of them
  this.addControl = function(id) {
    thingService.getAllThings(function(things) {
      // get by id
      ts = _.filter(things, function(t) {
        return t.id == id;
      });

      // calculate value
      switch (root.newControl.type) {
        case "bool":
        case "button":
          root.newControl.value = false;
          delete root.newControl.type;
          break;
        case "number":
          root.newControl.value = 0;
          delete root.newControl.type;
          break;
        case "canvas":
          break;
        default:
          root.newControl.value = "";
          delete root.newControl.type;
      };

      // add each control to the thing
      _.each(ts, function(thing) {
        // thing.data[root.newControl.name] = root.newControl;
        root.updateThingData(id, root.newControl.name, root.newControl, function(){});
      });
    });
  };

  this.deleteControl = function(id, cname, callback) {
    console.log(1)
    thingService.getAllThings(function(things) {

      // get all matching things
      things.filter(function(i) {
        return i.id == id;
      }).forEach(function(thing) {
        console.log(2)
        thing.data[cname] = null;
        thingService.updateThingData(id, thing.data, function() {
          callback && callback();
        });
      });

    });
  }

  this.refresh = function() {
    thingService.getAllThings(function(data) {
      if ( $(':focus').length == 0 || _.contains(["checkbox", "button"], $(':focus').attr("type"))) {
        // if a new item was added, hide the modal
        if (root.things.length !== data.length) {
          $("#addThingModal").modal('hide');
        }

        // update the data
        root.things = data;
      }
    });
  }

  socket.on('backend-data-change', function(payload) {
    if (payload && payload.type === "thing") {
      root.refresh();
      $scope.$apply();
    }
  });


  socket.on("canvas-update", function(data) {
    canvas = $(".canvas-"+data.id+"-"+data.key)[0];
    cxt = canvas.getContext('2d');

    // colors
    if (data.fillColor) cxt.fillStyle = data.fillColor
    if (data.strokeColor) cxt.strokeStyle = data.strokeColor

    // what to do?
    switch (data.action) {
      case "clear":
        cxt.clearRect(
          data.x || 0,
          data.y || 0,
          data.w || canvas.width,
          data.h || canvas.height
        );
        break;

      case "line":
        /*
        {
          action: "line",
          nodes: [
            [0, 0],
            [10, 10]
          ],
          fillColor: "red",
          strokeColor: "red",
          finished: "stroke"
        }
        */

        // start drawing line
        cxt.beginPath();
        cxt.moveTo(
          data.nodes[0][0],
          data.nodes[0][1]
        );

        // each node
        _.each(_.rest(data.nodes), function(n) {
          cxt.lineTo(n[0], n[1]);
        });

        // finish
        (data.finished == "fill") && cxt.fill();
        (data.finished == "stroke") && cxt.stroke();
        break;

      case "rect":
        // draw rectangle
        cxt.fillRect(
          data.x || 0,
          data.y || 0,
          data.w || canvas.width,
          data.h || canvas.height
        );
        break;

      case "text":
        // draw text
        cxt.fillText(data.text, data.x || 0, data.y || 0);
        break;

      case "image":
        // add image to canvas
        img = new Image();
        img.src = data.src;
        img.onload = function(){
          cxt.drawImage(img, data.x || 0, data.y || 0);
        }
        break;
    }
  });
});
